#include "encl_message.h"
#include "edge_wrapper.h"
#include <string.h>
/* Really all of this file should be autogenerated, that will happen
   eventually. */

#define OCALL_PRINT_BUFFER 1
#define OCALL_PRINT_VALUE 2
#define OCALL_COPY_REPORT 3
#define OCALL_WAIT_FOR_MESSAGE 4


int edge_init(Keystone* enclave){

  enclave->registerOcallDispatch(incoming_call_dispatch);
  register_call(OCALL_PRINT_BUFFER, print_buffer_wrapper);
  register_call(OCALL_PRINT_VALUE, print_value_wrapper);
  register_call(OCALL_COPY_REPORT, copy_report_wrapper);
  register_call(OCALL_WAIT_FOR_MESSAGE, wait_for_message_wrapper);
}


void print_buffer_wrapper(void* shared_buffer, size_t shared_buffer_size)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)shared_buffer;

  uintptr_t data_section;
  unsigned long ret_val;
  if(edge_call_get_ptr_from_offset((uintptr_t)shared_buffer, shared_buffer_size,
				   edge_call->call_arg_offset, sizeof(edge_data_t),
				   &data_section) != 0){
    // Need to raise some error somewhere, oh well
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  ret_val = print_buffer((char*)data_section);
  // We are done with the data section for args, use as return region
  // TODO safety check?
  memcpy((void*)data_section, &ret_val, sizeof(unsigned long));  
  edge_call->return_data.call_status = CALL_STATUS_OK;

  if(edge_call_get_offset_from_ptr((uintptr_t)shared_buffer, shared_buffer_size,
				   data_section, sizeof(unsigned long),
				   &(edge_call->return_data.call_ret_offset)) != 0){
    
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }

  return;
}

void print_value_wrapper(void* shared_buffer, size_t shared_buffer_size)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)shared_buffer;
  size_t pbw_data_len = 64;
  uintptr_t data_section;
  unsigned long ret_val;
  if(edge_call_get_ptr_from_offset((uintptr_t)shared_buffer, shared_buffer_size,
				     edge_call->call_arg_offset, pbw_data_len,
				     &data_section) != 0){
    // Need to raise some error somewhere, oh well
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
    return;
  }

  print_value(*(unsigned long*)data_section);

  edge_call->return_data.call_status = CALL_STATUS_OK;

  return;
}

void copy_report_wrapper(void* shared_buffer, size_t shared_buffer_size)
{
  struct edge_call_t* edge_call = (struct edge_call_t*) shared_buffer;

  uintptr_t data_section;
  unsigned long ret_val;
  if(edge_call_get_ptr_from_offset((uintptr_t) shared_buffer, shared_buffer_size,
				   edge_call->call_arg_offset, sizeof(report_t),
				   &data_section) != 0) {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  
  copy_report((void*)data_section);

  edge_call->return_data.call_status = CALL_STATUS_OK;

  return;
}

void wait_for_message_wrapper(void* shared_buffer, size_t shared_buffer_size)
{
  struct edge_call_t* edge_call = (struct edge_call_t*) shared_buffer;

  uintptr_t data_section;

  data_section = (uintptr_t)shared_buffer+sizeof(struct edge_call_t);
  unsigned long ret_val;

  encl_message_t host_msg = wait_for_message();

  /* Now we will repackage this into offsets for the app, and load all
     of it into the shared data region */
  
  /* Setup the offset for the app packaged string */
  if(edge_call_get_offset_from_ptr((uintptr_t) shared_buffer, shared_buffer_size,
				   data_section, sizeof(edge_data_t),
				   &edge_call->return_data.call_ret_offset) != 0) {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
    return;
  }

  /* Setup the offset for the actual string data */
  edge_data_t* edge_msg = (edge_data_t*)data_section;
  edge_msg->len = host_msg.len;
  uintptr_t shared_data_ptr = data_section+sizeof(edge_data_t);
  
  /* TODO we want a better recovery mode here if the input string is
     too long */
  if(edge_call_get_offset_from_ptr((uintptr_t) shared_buffer, shared_buffer_size,
				   shared_data_ptr, host_msg.len,
				   &edge_msg->offset) != 0) {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
    return;
  }

  /* Copy the string */  
  memcpy((void*)shared_data_ptr, (void*)host_msg.host_ptr, host_msg.len);
  
  edge_call->return_data.call_status = CALL_STATUS_OK;

  return;
  
  
}
